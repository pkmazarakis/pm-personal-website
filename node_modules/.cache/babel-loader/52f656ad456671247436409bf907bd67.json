{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[IS_EQUAL_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = function interrupt() {\n      interruptablePromise[INTERRUPT_PROMISE] = undefined;\n      resolve();\n    };\n\n    promise.then(interrupt, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\n\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n  };\n\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return nextAtomState;\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    var interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var atomState = prepareNextAtomState(atom);\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              var aState = getAtomState(a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(function () {\n                return readAtomState(atom, true);\n              });\n            }\n\n            return e;\n          }\n\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n\n      var aState = readAtomState(a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n      var atomState = getAtomState(atom);\n\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, (prevAtomState == null ? void 0 : prevAtomState.d) || new Map());\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        stateListeners.forEach(function (l) {\n          return l(atom, !prevAtomState);\n        });\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom) {\n    flushPending();\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomValue(_atom2, _value);\n        invalidateDependents(_atom2);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nvar ScopeContextMap = new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState = react.useState([]),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n  var store = react.useContext(ScopeContext).s;\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n      value = _useReducer[0],\n      forceUpdate = _useReducer[1];\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;","map":{"version":3,"sources":["/Users/platonmazarakis/coding-projects/pm-personal-website/node_modules/jotai/index.js"],"names":["Object","defineProperty","exports","value","react","require","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","TypeError","hasInitialValue","atom","IS_EQUAL_PROMISE","INTERRUPT_PROMISE","isInterruptablePromise","promise","createInterruptablePromise","interrupt","interruptablePromise","Promise","resolve","reject","undefined","then","p","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref4","atomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","_iterator","_step","_step$value","atomState","v","r","d","freeze","console","warn","set","getAtomState","get","setAtomState","prevAtomState","has","prepareNextAtomState","dependencies","nextAtomState","map","a","_getAtomState$r","_getAtomState","setAtomValue","_atomState$p","c","is","e","setAtomReadError","error","_atomState$p2","setAtomReadPromise","_atomState$p3","setAtomInvalidated","readAtomState","force","_atomState","forEach","_","aState","entries","every","_ref","promiseOrValue","read","add","init","Error","flushPending","catch","finally","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","size","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","writeGetter","unstable_promise","info","setter","promiseOrVoid","resolvedValue","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","_mountedMap$get","delete","mountDependencies","prevReadDependencies","keys","pending","clear","_ref2","listener","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom2","_value","_ref3","createScopeContainer","store","s","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","scopeContainerRef","useRef","current","useDebugState","ScopeContainerContext","createElement","atomToPrintable","debugLabel","stateToPrintable","atoms","fromEntries","flatMap","_store$DEV_GET_MOUNTE","_store$DEV_GET_ATOM_S","dependents","scopeContainer","_useState","useState","setAtoms","useEffect","_store$DEV_SUBSCRIBE_","_store$DEV_GET_MOUNTE2","unsubscribe","useDebugValue","keyCount","config","isWritable","useAtom","ScopeContext","useContext","getAtomValue","useCallback","_useReducer","useReducer","forceUpdate","SECRET_INTERNAL_getScopeContext"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[IS_EQUAL_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = function interrupt() {\n      interruptablePromise[INTERRUPT_PROMISE] = undefined;\n      resolve();\n    };\n\n    promise.then(interrupt, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n  };\n\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return nextAtomState;\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    var interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var atomState = prepareNextAtomState(atom);\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              var aState = getAtomState(a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(function () {\n                return readAtomState(atom, true);\n              });\n            }\n\n            return e;\n          }\n\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n\n      var aState = readAtomState(a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n      var atomState = getAtomState(atom);\n\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, (prevAtomState == null ? void 0 : prevAtomState.d) || new Map());\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        stateListeners.forEach(function (l) {\n          return l(atom, !prevAtomState);\n        });\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom) {\n    flushPending();\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomValue(_atom2, _value);\n        invalidateDependents(_atom2);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState = react.useState([]),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n  var store = react.useContext(ScopeContext).s;\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n      value = _useReducer[0],\n      forceUpdate = _useReducer[1];\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;\n"]},"metadata":{},"sourceType":"script"}